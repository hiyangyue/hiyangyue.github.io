<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="YueYang"><title>ArrayList原理实现 · YueYang's Blog</title><meta name="description" content="ArrayList的特点
动态数组，容量可以自增长
线程不安全(不考虑性能的情况下，可以使用Collections.synchronizedList()返回一个线程安全的ArrayList类)
实现了Serializable接口，支持序列化
实现了RandomAccess接口，支持随机访问
实现了C"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">YueYang's Blog</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>ArrayList原理实现</a></h3></div><div class="post-content"><h5 id="ArrayList的特点"><a href="#ArrayList的特点" class="headerlink" title="ArrayList的特点"></a>ArrayList的特点</h5><ul>
<li>动态数组，容量可以自增长</li>
<li>线程不安全<br>(不考虑性能的情况下，可以使用Collections.synchronizedList()返回一个线程安全的ArrayList类)</li>
<li>实现了Serializable接口，支持序列化</li>
<li>实现了RandomAccess接口，支持随机访问</li>
<li>实现了Cloneable接口，能够被克隆</li>
</ul>
<h5 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h5><p> ArrayList有三种形式的构造器 :</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">//该数组用于保存数据，是ArrayList的基础</div><div class="line">private transient Object[] elementData;    </div><div class="line"></div><div class="line">//实际数据的数量    </div><div class="line">private int size;</div><div class="line"></div><div class="line">//指定初始容量的构造器</div><div class="line">public ArrayList(int initialCapacity) &#123;</div><div class="line">  //判断initialCapacity是否合法</div><div class="line">       if (initialCapacity &gt; 0) &#123;</div><div class="line">           this.elementData = new Object[initialCapacity];</div><div class="line">       &#125; else if (initialCapacity == 0) &#123;</div><div class="line">           this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">       &#125; else &#123;</div><div class="line">           throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</div><div class="line">                                              initialCapacity);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //默认大小的构造器，DEFAULT_CAPACITY = 10</div><div class="line">   public ArrayList() &#123;</div><div class="line">       this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">   &#125;</div><div class="line"></div><div class="line">   //包含指定Collection的构造器，这些元素按照迭代器返回它们的顺序排列</div><div class="line">   public ArrayList(Collection&lt;? extends E&gt; c) &#123;</div><div class="line">       elementData = c.toArray();</div><div class="line">       if ((size = elementData.length) != 0) &#123;</div><div class="line">           // c.toArray might (incorrectly) not return Object[] (see 6260652)</div><div class="line">           if (elementData.getClass() != Object[].class)</div><div class="line">               elementData = Arrays.copyOf(elementData, size, Object[].class);</div><div class="line">       &#125; else &#123;</div><div class="line">           this.elementData = EMPTY_ELEMENTDATA;</div><div class="line">       &#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<h5 id="调整数组容量"><a href="#调整数组容量" class="headerlink" title="调整数组容量"></a>调整数组容量</h5><p>每当向数组中添加元素时，都需要对元素的个数进行检查，防止数组越界。如果超出，就需要对数组进行扩容。默认情况下，可以通过 public方法ensureCapacity(int minCapacity)调整ArrayList的容量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public void ensureCapacity(int minCapacity) &#123;</div><div class="line">        int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</div><div class="line">            // any size if not default element table</div><div class="line">            ? 0</div><div class="line">            // larger than default for default empty table. It&apos;s already</div><div class="line">            // supposed to be at default size.</div><div class="line">            : DEFAULT_CAPACITY;</div><div class="line"></div><div class="line">        if (minCapacity &gt; minExpand) &#123;</div><div class="line">		  //扩容</div><div class="line">            ensureExplicitCapacity(minCapacity);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果所需要的容量大小minCapacity大于实际容量的话，则需要对当前的数组进行扩容 ：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void grow(int minCapacity) &#123;</div><div class="line">        // 当前数组的容量</div><div class="line">        int oldCapacity = elementData.length;</div><div class="line">		  // 新的数组容量为当前数组容量的1.5倍</div><div class="line">        int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</div><div class="line">		  // 如果新的数组的容量小于就的数组的容量，则默认的数组大小为当前数组的容量</div><div class="line">        if (newCapacity - minCapacity &lt; 0)</div><div class="line">            newCapacity = minCapacity;</div><div class="line">	      // 如果新的数组的容量超过了Integer的最大值，则默认的数组大小这个最大值</div><div class="line">        if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div class="line">            newCapacity = hugeCapacity(minCapacity);</div><div class="line">        // minCapacity is usually close to size, so this is a win:</div><div class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>从代码上可以看出，在对数组进行扩容的时候，会将老数组中的元素依次拷贝到新的数组里面，所以在实际使用中，应该尽量避免数组扩容。</p>
<h5 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h5><p>在数组为的尾部添加一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public boolean add(E e) &#123;</div><div class="line">		 //确定ArrayList容量的大小</div><div class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">       elementData[size++] = e;</div><div class="line">       return true;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>在指定位置添加一个元素<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">public void add(int index, E element) &#123;</div><div class="line">       //首先判断指定位置的index是否有效(&lt;0或者超过当前数组的容量)</div><div class="line">       rangeCheckForAdd(index);</div><div class="line">       //确定ArrayList容量的大小</div><div class="line">       ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div class="line">		  //调用System.arraycopy将elementData从index开始的size-index个元素复制到index+1至size+1的位置</div><div class="line">       System.arraycopy(elementData, index, elementData, index + 1,</div><div class="line">                        size - index);</div><div class="line">       elementData[index] = element;</div><div class="line">       size++;</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<h5 id="读取元素"><a href="#读取元素" class="headerlink" title="读取元素"></a>读取元素</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public E get(int index) &#123;</div><div class="line">       rangeCheck(index);</div><div class="line">       return elementData(index);</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>因为数组本身支持随机访问，所以get(int index)方法首先会判断index的值是否有效，然后返回对应位置的元素即可.</p>
<h5 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h5><ul>
<li>根据下标删除元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">public E remove(int index) &#123;</div><div class="line">        rangeCheck(index);</div><div class="line"></div><div class="line">        modCount++;</div><div class="line">		  //保存要被移除的元素，用于方法的返回</div><div class="line">        E oldValue = elementData(index);</div><div class="line"></div><div class="line">        int numMoved = size - index - 1;</div><div class="line">        if (numMoved &gt; 0)</div><div class="line">            System.arraycopy(elementData, index+1, elementData, index,</div><div class="line">                             numMoved);</div><div class="line">        elementData[--size] = null; // clear to let GC do its work</div><div class="line"></div><div class="line">        return oldValue;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>从数组中删除元素的操作，会导致移除位置的后面的元素向前移动一个位置。</p>
<ul>
<li>根据指定元素删除元素<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">public boolean remove(Object o) &#123;</div><div class="line">        if (o == null) &#123;</div><div class="line">            for (int index = 0; index &lt; size; index++)</div><div class="line">                if (elementData[index] == null) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            for (int index = 0; index &lt; size; index++)</div><div class="line">                if (o.equals(elementData[index])) &#123;</div><div class="line">                    fastRemove(index);</div><div class="line">                    return true;</div><div class="line">                &#125;</div><div class="line">        &#125;</div><div class="line">        return false;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>ArrayList中允许元素为null，所以应该分null和不为null两种情况处理。成功移除以后，返回true，否则返回false。fastRemove(int index)的remove(int index)基本一样，区别在于fastRemove(int index) 并不会返回被移除的元素。</p>
<h5 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public void trimToSize() &#123;</div><div class="line">      modCount++;</div><div class="line">      if (size &lt; elementData.length) &#123;</div><div class="line">          elementData = (size == 0)</div><div class="line">            ? EMPTY_ELEMENTDATA</div><div class="line">            : Arrays.copyOf(elementData, size);</div><div class="line">      &#125;</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<p>elementData.length是当前数组的长度，size则是当前元素的实际大小，在扩容的情况下，有可能会出现elementData.length很大，size很小的情况，这样就会造成空间上的浪费，所以trimToSize()返回了一个新的数组给elementData，是elementData.length和size一样。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2016-12-21</span><i class="fa fa-tag"></i><a href="/categories/Android/" title="Android" class="tag">Android </a><a href="/tags/Java/" title="Java" class="tag">Java </a><a href="/tags/ArrayList/" title="ArrayList" class="tag">ArrayList </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://hiyangyue.github.io/2016/12/21/arraylist/,YueYang's Blog,ArrayList原理实现,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2016/12/21/link_list/" title="LinkedList原理实现" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/07/24/test_case/" title="Android中测试用例的关注点" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>