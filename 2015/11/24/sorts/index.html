<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="YueYang"><title>常用排序算法 · YueYang's Blog</title><meta name="description" content="冒泡排序(Bubble Sort)
冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮"><meta name="keywords"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">YueYang's Blog</a></h3></div></div><ul class="social-links"></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"></a></li></div><div class="avatar"><img></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>常用排序算法</a></h3></div><div class="post-content"><h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h4><blockquote>
<p>冒泡排序（Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
</blockquote>
<p>步骤：</p>
<ol>
<li>从第一个数开始，依次 比较相邻的两个元素</li>
<li>如果前一个数大于后一个数，则交换它们的位置</li>
<li>经过一轮遍历之后，最大的元素在这组元素的末端</li>
<li>重复步骤 1 ~ 2，每次遍历N - 1，如果N = 0 ，则完成排序</li>
</ol>
<a id="more"></a>
<pre><code>
void bubblesort(int[] a){
        for(int i = 0 ; i < a.length - 1; i ++){
            for(int j = 1 ; j < a.length - i - 1; i ++){
                if( a[j-1] > a[j]){
                    swap(a[j-1], a[j]);
                }
            }
        }
    }
</code></pre>


<hr>
<h4 id="插入排序-Insert-Sort"><a href="#插入排序-Insert-Sort" class="headerlink" title="插入排序(Insert Sort)"></a>插入排序(Insert Sort)</h4><blockquote>
<p>插入排序（Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用in-place排序（即只需用到O(1)的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p>
</blockquote>
<p>插入排序很像平时的扑克，通常我们在“斗地主”的是时候整理牌的方法时一张一张的来，将每一张牌插入到其他已经有序的牌中的适当的位置，同理，数组当前索引左边的所有元素都是有序的，为了给要插入的元素腾出空间，我们需要将所有元素在插入之前都像右移动一位；另外，可以看出，插入排序的复杂度和<b>输入元素的初始位置有关</b>。</p>
<p>步骤：</p>
<ol>
<li>从第一个元素开始，默认第一个元素已经排好序</li>
<li>设取出的元素的位置为i，从后向前扫描，若每次比较中，取出的元素小于前面的元素，则前面的元素后移一位(可以理解为i-1)</li>
<li>循环结束之后，将取出元素插入到当前i的位置</li>
<li>重复 1 ~ 3</li>
</ol>
<pre><code>
void insertSort(int a[]){  
        int length=a.length; //数组长度  
        int j;               //当前值的位置  
        int i;               //指向j前的位置  
        int key;             //当前要进行插入排序的值  
        //从数组的第二个位置开始遍历值  
        for(j=1;j<length;j++){ key="a[j];" i="j-1;" a[i]比当前值大时，a[i]后移一位,空出i的位置，好让下一次循环的值后移="" while(i="">=0 && a[i]>key){  
                a[i+1]=a[i]; //将a[i]值后移  
                i--;         //i前移  
            }//跳出循环(找到要插入的中间位置或已遍历到0下标)  
            a[i+1]=key;    //将当前值插入  
        }  
    }
</length;j++){></code></pre>




<hr>
<h4 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序(Shell Sort)"></a>希尔排序(Shell Sort)</h4><p>原本的插入算法，在对大规模的数组进行排序时，由于它只会交换相邻元素的位置，若每次只能一个一个从数组的开端到数组的末端，那么从开端到末端就需要N - 1次。基于这样的观察，希尔排序提出了改进的方法：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位</li>
</ol>
<p>建立在这两点的基础上，希尔排序则是交换不相邻的对数组的局部进行排序，并最终使用插入排序将局部有序的数组进行排序。</p>
<blockquote>
<p>h有序数组：对于任意间隔为h的元素都是有序的，</p>
</blockquote>
<p>换句话说任意一个h的有序数组就是h个相互有序的数组组成的一个数组，在进行排序时，若h很大，就能很轻松将开端的数组移动到后半部分。</p>
<p>思路：</p>
<ol>
<li>将初始素组分成若干个间隔为h的有效数组</li>
<li>对这些数组进行排序</li>
<li>缩小h的取值，重复 1 ~ 2，直到h = 1的时候，完成排序</li>
</ol>
<pre><code>

void shellSort(int a[]){
        int N = a.length;
        int h = 1;
        while(h < N /3){
            h = 3*h + 1;
        }

        while(h >= 1){
             for(int i = h ; i < N ; i ++){
                 for(int j = i ; j >= h && a[j-h] > a[j];j -= h){
                     exch(a[j-h], a[j]);
                 }
             }

             h = h / 3;
        }
    }
</code></pre>



<h4 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序(Quick Sort)"></a>快速排序(Quick Sort)</h4><blockquote>
<p>设要排序的数组是A[0]……A[N-1]，首先任意选取一个数据（通常选用数组的第一个数）作为关键数据，然后将所有比它小的数都放到它前面，所有比它大的数都放到它后面，这个过程称为一趟快速排序。值得注意的是，快速排序不是一种稳定的排序算法，也就是说，多个相同的值的相对位置也许会在算法结束时产生变动。</p>
</blockquote>
<p>思路：</p>
<ol>
<li>确定数组中的一个位置，使得当前位置左边的所有数都小于当前的,右边的所有数都大于当前的值。</li>
</ol>
<p>确定切分的位置</p>
<pre><code>
int partition(int a[],int lo,int high){
        int x = a[high];
        int i = lo - 1;
        for(int j = lo; j < high ; j ++){
            if(a[j] < x){
                ++ i;
                swap(a[i], a[j]);
            }

        }

        swap(a[i+ 1], a[high]);

        return i + 1;
    }
</code></pre>


<pre><code>
void quickSort(int a[],int lo,int high){
        if(lo < high){
            int index = partition(a, lo, high);
            quickSort(a, lo, index - 1);
            quickSort(a, index + 1, high);
        }
    }
</code></pre>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2015-11-24</span><i class="fa fa-tag"></i><a href="/categories/算法/" title="算法" class="tag">算法 </a><a href="/tags/排序/" title="排序" class="tag">排序 </a><a href="/tags/算法/" title="算法" class="tag">算法 </a></div></div></div></div><div class="share"><div class="evernote"><a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"><a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"><a href="http://twitter.com/home?status=,http://hiyangyue.github.io/2015/11/24/sorts/,YueYang's Blog,常用排序算法,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2013/07/13/proguard/" title="Android 代码混淆" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2015/11/24/view/" title="自定义View" class="btn">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>